<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Source &mdash; PyActor 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="PyActor 0.1 documentation" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyActor 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="source">
<span id="id1"></span><h1>Source<a class="headerlink" href="#source" title="Permalink to this headline">¶</a></h1>
<div class="section" id="context">
<span id="context-source"></span><h2>Context<a class="headerlink" href="#context" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">signal</span> <span class="k">import</span> <span class="n">SIGINT</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">urlparse</span> <span class="k">import</span> <span class="n">urlparse</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">proxy</span> <span class="k">import</span> <span class="n">Proxy</span><span class="p">,</span> <span class="n">set_actor</span>
<span class="kn">from</span> <span class="nn">util</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">util</span>

<span class="n">CLEAN_INT</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">core_type</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">available_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;thread&#39;</span><span class="p">,</span> <span class="s1">&#39;green_thread&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">set_context</span><span class="p">(</span><span class="n">module_name</span><span class="o">=</span><span class="s1">&#39;thread&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function initializes the context of execution deciding which</span>
<span class="sd">    type of threads are being used, normal python threads or green</span>
<span class="sd">    threads, provided by Gevent.</span>

<span class="sd">    This should be called first of all in every execution, otherwise,</span>
<span class="sd">    the library would not work.</span>

<span class="sd">    The default module is &#39;thread&#39;.</span>

<span class="sd">    :param str. module_name: Name of the module you want to use</span>
<span class="sd">        (&#39;thread&#39; or &#39;green_thread&#39;).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">core_type</span>
    <span class="k">if</span> <span class="n">core_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">module_name</span> <span class="ow">in</span> <span class="n">available_types</span><span class="p">:</span>
        <span class="n">core_type</span> <span class="o">=</span> <span class="n">module_name</span>
        <span class="n">util</span><span class="o">.</span><span class="n">core_type</span> <span class="o">=</span> <span class="n">core_type</span>
        <span class="k">global</span> <span class="n">actor</span>
        <span class="n">actor</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;pyactor.&#39;</span> <span class="o">+</span> <span class="n">module_name</span> <span class="o">+</span> <span class="s1">&#39;.actor&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span>
                           <span class="nb">locals</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;Actor&#39;</span><span class="p">,</span> <span class="s1">&#39;ActorRef&#39;</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">global</span> <span class="n">intervals</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;pyactor.&#39;</span> <span class="o">+</span> <span class="n">module_name</span> <span class="o">+</span> <span class="s1">&#39;.intervals&#39;</span><span class="p">,</span>
                               <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span>
                               <span class="p">[</span><span class="s1">&#39;interval_host&#39;</span><span class="p">,</span> <span class="s1">&#39;sleep&#39;</span><span class="p">,</span> <span class="s1">&#39;later&#39;</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">global</span> <span class="n">parallels</span>
        <span class="n">parallels</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;pyactor.&#39;</span> <span class="o">+</span> <span class="n">module_name</span> <span class="o">+</span> <span class="s1">&#39;.parallels&#39;</span><span class="p">,</span>
                               <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span>
                               <span class="p">[</span><span class="s1">&#39;ActorParallel&#39;</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">set_actor</span><span class="p">(</span><span class="n">module_name</span><span class="p">)</span>
        <span class="k">global</span> <span class="n">signal</span>
        <span class="k">if</span> <span class="n">module_name</span> <span class="o">==</span> <span class="s1">&#39;green_thread&#39;</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;gevent&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Bad core type.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">create_host</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s2">&quot;local://local:6666/host&quot;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This is the main function to create a new Host to which you can</span>
<span class="sd">    spawn actors. It will be set by default at local address if no</span>
<span class="sd">    parameter *url* is given. This function shuould be called once for</span>
<span class="sd">    execution or after callig :meth:`~.shutdown` to the previous host.</span>

<span class="sd">    It is possible to create locally more than one host and simulate a</span>
<span class="sd">    remote communication between them, but the first one created will</span>
<span class="sd">    be the main host, which is the one that will host the queries from</span>
<span class="sd">    the main function.</span>
<span class="sd">    Of course, every host must be initialized with a diferent URL(port)</span>
<span class="sd">    Even so, more than one host should not be requiered for any real</span>
<span class="sd">    project.</span>

<span class="sd">    :param str. url: URL where to start and bind the host.</span>
<span class="sd">    :return: :class:`~.Host` created.</span>
<span class="sd">    :rise: Exception if there is a host already created.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">hosts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Host already created. Only one host can&#39;</span> <span class="o">+</span>
                        <span class="s1">&#39; be ran with the same url.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">util</span><span class="o">.</span><span class="n">hosts</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">main_host</span> <span class="o">=</span> <span class="n">Host</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="n">util</span><span class="o">.</span><span class="n">hosts</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">main_host</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">hosts</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">=</span> <span class="n">Host</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">hosts</span><span class="p">[</span><span class="n">url</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Host</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Host must be created using the function :func:`~create_host`.</span>
<span class="sd">    Do not create a Host directly.</span>

<span class="sd">    Host is the container of the actors. It manages the spawn and</span>
<span class="sd">    elimination of actors and their communication through channels. Also</span>
<span class="sd">    configures the TCP socket where the actors will be able to receive</span>
<span class="sd">    queries remotely. Additionaly, controls the correct management of</span>
<span class="sd">    the threads and intervals of its actors.</span>

<span class="sd">    The host can be managed as a simple object, but it also is an actor</span>
<span class="sd">    itself so you can get its :class:`~.Proxy` (with ``host.proxy``) and</span>
<span class="sd">    pass it to another host to spawn remotely.</span>

<span class="sd">    :param str. url: URL that identifies the host.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">_tell</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;attach_interval&#39;</span><span class="p">,</span> <span class="s1">&#39;detach_interval&#39;</span><span class="p">]</span>
    <span class="n">_ask</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spawn&#39;</span><span class="p">,</span> <span class="s1">&#39;lookup&#39;</span><span class="p">,</span> <span class="s1">&#39;spawn_n&#39;</span><span class="p">,</span> <span class="s1">&#39;lookup_url&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pthreads</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_transport</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_host</span><span class="p">()</span>

        <span class="c1"># self.cleaner = interval_host(get_host(), CLEAN_INT, self.do_clean)</span>

    <span class="k">def</span> <span class="nf">load_transport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        ### Not yet functional</span>
<span class="sd">        For TCP communication. Sets the communication socket of the host</span>
<span class="sd">        at the address and port specified.</span>

<span class="sd">        :param str. url: URL where to bind the host. Must be provided in</span>
<span class="sd">            the tipical form: &#39;scheme://address:port/hierarchical_path&#39;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">aurl</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">addrl</span> <span class="o">=</span> <span class="n">aurl</span><span class="o">.</span><span class="n">netloc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addrl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">addrl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">aurl</span><span class="o">.</span><span class="n">scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">host_url</span> <span class="o">=</span> <span class="n">aurl</span>

        <span class="c1"># if aurl.scheme == &#39;tcp&#39;:</span>
        <span class="c1">#     self.tcp = Server(self.addr)</span>
        <span class="c1">#     dispatcher = self.tcp.get_dispatcher(self.addr)</span>
        <span class="c1">#     launch_actor(self.addr,dispatcher)</span>

    <span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This method creates an actor attached to this host. It will be</span>
<span class="sd">        an instance of the class *klass* and it will be assigned an ID</span>
<span class="sd">        that identifies it among the host.</span>

<span class="sd">        This method can be called remotely synchronously.</span>

<span class="sd">        :param str. id: identifier for the spawning actor. Unique within</span>
<span class="sd">            the host.</span>
<span class="sd">        :param class klass: class type of the spawning actor.</span>
<span class="sd">        :param list args: arguments for the init function of the</span>
<span class="sd">            spawning actor class.</span>
<span class="sd">        :return: :class:`~.Proxy` of the actor spawned.</span>
<span class="sd">        :raises: :class:`AlreadyExistsError`, if the ID specified is</span>
<span class="sd">            already in use.</span>
<span class="sd">        :raises: :class:`HostDownError` if there is no host initiated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HostDownError</span><span class="p">()</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">://</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">host_url</span><span class="o">.</span><span class="n">netloc</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">url</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">actors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">AlreadyExistsError</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">klass</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">host</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proxy</span>
            <span class="c1"># else:</span>
            <span class="c1">#     obj.host = Exception(&quot;Host is not an active actor. \</span>
            <span class="c1">#                           Use &#39;init_host&#39; to make it alive.&quot;)</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="s1">&#39;_parallel&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">klass</span><span class="o">.</span><span class="n">_parallel</span><span class="p">:</span>
                <span class="n">new_actor</span> <span class="o">=</span> <span class="n">parallels</span><span class="o">.</span><span class="n">ActorParallel</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
                <span class="n">lock</span> <span class="o">=</span> <span class="n">new_actor</span><span class="o">.</span><span class="n">get_lock</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">locks</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">=</span> <span class="n">lock</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_actor</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">Actor</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

            <span class="n">obj</span><span class="o">.</span><span class="n">proxy</span> <span class="o">=</span> <span class="n">Proxy</span><span class="p">(</span><span class="n">new_actor</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">launch_actor</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">new_actor</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Proxy</span><span class="p">(</span><span class="n">new_actor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Gets a new proxy that references to the actor of this host</span>
<span class="sd">        identified by the given ID.</span>

<span class="sd">        This method can be called remotely synchronously.</span>

<span class="sd">        :param str. id: identifier of the actor you want.</span>
<span class="sd">        :return: :class:`~.Proxy` of the actor requiered.</span>
<span class="sd">        :raises: :class:`NotFoundError`  if the actor does not exist.</span>
<span class="sd">        :raises: :class:`HostDownError`  if the host is down.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HostDownError</span><span class="p">()</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">://</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">host_url</span><span class="o">.</span><span class="n">netloc</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">url</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">actors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">Proxy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actors</span><span class="p">[</span><span class="n">url</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotFoundError</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Stops the Host, stopping at the same time all its actors.</span>
<span class="sd">        Should be called at the end of its usage, to finish correctly</span>
<span class="sd">        all the connections and threads.</span>
<span class="sd">        When the actors stop running, they can&#39;t be started again and</span>
<span class="sd">        the host can&#39;t process new spawns. You might need to create a</span>
<span class="sd">        new host (:func:`create_host`).</span>

<span class="sd">        This method can&#39;t be called remotely.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># print self.pthreads</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">interval_event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">interval_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">actor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">actors</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">Proxy</span><span class="p">(</span><span class="n">actor</span><span class="p">)</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">parall</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pthreads</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">parall</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">locks</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actors</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pthreads</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">del</span> <span class="n">util</span><span class="o">.</span><span class="n">hosts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">main_host</span><span class="o">.</span><span class="n">url</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">main_host</span> <span class="o">=</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">hosts</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">hosts</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                                  <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lookup_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Gets a proxy reference to the actor indicated by the URL in the</span>
<span class="sd">        parameters. It can be a local reference or a TCP direction.</span>

<span class="sd">        This method can be called remotely synchronously.</span>

<span class="sd">        :param srt. url: address that identifies an actor.</span>
<span class="sd">        :return: :class:`~.Proxy` of the actor requested.</span>
<span class="sd">        :raise: :class:`NotFoundError`, if the URL specified do not</span>
<span class="sd">            correspond to any actor in the host.</span>
<span class="sd">        :raises: :class:`HostDownError`  if the host is down.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HostDownError</span><span class="p">()</span>
        <span class="n">aurl</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_local</span><span class="p">(</span><span class="n">aurl</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">url</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">actors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">NotFoundError</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Proxy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actors</span><span class="p">[</span><span class="n">url</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;TCPthing&quot;</span><span class="p">)</span>
            <span class="c1"># addrl = aurl.netloc.split(&#39;:&#39;)</span>
            <span class="c1"># addr = addrl[0],addrl[1]</span>
            <span class="c1"># if actors.has_key(addr):</span>
            <span class="c1">#     dispatcher = actors[addr]</span>
            <span class="c1"># else:</span>
            <span class="c1">#     dispatcher = self.tcp.get_dispatcher(addr)</span>
            <span class="c1">#     launch_actor(addr,dispatcher)</span>
            <span class="c1"># remote_actor = ActorRef(url,klass,dispatcher.channel)</span>
            <span class="c1"># return Proxy(remote_actor)</span>

    <span class="k">def</span> <span class="nf">is_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aurl</span><span class="p">):</span>
        <span class="c1"># &#39;&#39;&#39;Private method.</span>
        <span class="c1"># Tells if the address given is from this host.</span>
        <span class="c1">#</span>
        <span class="c1"># :param ParseResult aurl: address to analyze.</span>
        <span class="c1"># :return: (*Bool.*) If is local (**True**) or not (**False**).</span>
        <span class="c1"># &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">host_url</span><span class="o">.</span><span class="n">netloc</span> <span class="o">==</span> <span class="n">aurl</span><span class="o">.</span><span class="n">netloc</span>

    <span class="k">def</span> <span class="nf">launch_actor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">actor</span><span class="p">):</span>
        <span class="c1"># &#39;&#39;&#39;Private method.</span>
        <span class="c1"># This function makes an actor alive to start processing queries.</span>
        <span class="c1">#</span>
        <span class="c1"># :param str. url: identifier of the actor.</span>
        <span class="c1"># :param Actor actor: instance of the actor.</span>
        <span class="c1"># &#39;&#39;&#39;</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actors</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">=</span> <span class="n">actor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="p">[</span><span class="n">actor</span><span class="o">.</span><span class="n">thread</span><span class="p">]</span> <span class="o">=</span> <span class="n">url</span>

    <span class="k">def</span> <span class="nf">init_host</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This method creates an actor for the Host so it can spawn actors</span>
<span class="sd">        remotely. Called always from the init function of the host, so</span>
<span class="sd">        no need for calling this directly.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">url</span>
            <span class="n">host</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">Actor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">Host</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proxy</span> <span class="o">=</span> <span class="n">Proxy</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">launch_actor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># &#39;&#39;&#39;</span>
        <span class="c1"># This gets the signal of Ctrl+C and stops the host. It also ends</span>
        <span class="c1"># the execution. Needs the invocation of :meth:`serve_forever`.</span>
        <span class="c1">#</span>
        <span class="c1"># :param signal: SIGINT signal interruption sent with a Ctrl+C.</span>
        <span class="c1"># :param frame: the current stack frame. (not used)</span>
        <span class="c1"># &#39;&#39;&#39;</span>
        <span class="nb">print</span> <span class="s1">&#39;You pressed Ctrl+C!&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serving</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">serve_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This allows the host to keep alive indefinitely so its actors</span>
<span class="sd">        can receive queries at any time.</span>
<span class="sd">        To kill the execution, press Ctrl+C.</span>

<span class="sd">        See usage example in :ref:`sample6`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This host is already shutted down.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serving</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_handler</span><span class="p">)</span>
        <span class="nb">print</span> <span class="s1">&#39;Press Ctrl+C to kill the execution&#39;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">serving</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="nb">print</span> <span class="s1">&#39;BYE!&#39;</span>

    <span class="k">def</span> <span class="nf">attach_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_id</span><span class="p">,</span> <span class="n">interval_event</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Registers an interval event to the host.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">interval_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval_event</span>

    <span class="k">def</span> <span class="nf">detach_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_id</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Deletes an interval event from the host registry.&#39;&#39;&#39;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">interval_id</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Checks the parameters generating new proxy instances to avoid</span>
<span class="sd">        query concurrences from shared proxies.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">Proxy</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_url</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dumps</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">param</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">new_dict</span> <span class="o">=</span> <span class="n">param</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">new_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dumps</span><span class="p">(</span><span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">new_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">param</span>

    <span class="k">def</span> <span class="nf">_loads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Checks the return parameters generating new proxy instances to</span>
<span class="sd">        avoid query concurrences from shared proxies.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">Proxy</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_url</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_loads</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">param</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">new_dict</span> <span class="o">=</span> <span class="n">param</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">new_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loads</span><span class="p">(</span><span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">new_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">param</span>

    <span class="k">def</span> <span class="nf">new_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_url</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Register a new thread executing a parallel method.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># for t in self.pthreads.keys():</span>
        <span class="c1">#     if self.pthreads[t] == from_url:</span>
        <span class="c1">#         if not t.ready():</span>
        <span class="c1">#             del self.pthreads[t]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pthreads</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">from_url</span>

    <span class="c1"># def do_clean(self):</span>
    <span class="c1">#     &#39;&#39;&#39;</span>
    <span class="c1">#     This function is called at intervals to delete the threads</span>
    <span class="c1">#     created for parallel methods that have already stopped.</span>
    <span class="c1">#     &#39;&#39;&#39;</span>
    <span class="c1">#     for t in self.pthreads.values():</span>
    <span class="c1">#         if not t.isAlive():</span>
    <span class="c1">#             del self.pthreads[t]</span>


<span class="k">def</span> <span class="nf">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Facade for the sleep function. Do not use time.sleep if you are</span>
<span class="sd">    running green threads.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">intervals</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">interval_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creates an Event attached to the *host* for management that will</span>
<span class="sd">    execute the *f* function every *time* seconds.</span>

<span class="sd">    See example in :ref:`sample_inter`</span>

<span class="sd">    :param Proxy host: proxy of the host. Can be obtained from inside a</span>
<span class="sd">        class with ``self.host``.</span>
<span class="sd">    :param int time: seconds for the intervals.</span>
<span class="sd">    :param func f: function to be called every *time* seconds.</span>
<span class="sd">    :param list args: arguments for *f*.</span>
<span class="sd">    :return: :class:`Event` instance of the interval.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">intervals</span><span class="o">.</span><span class="n">interval_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">later</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Sets a timer that will call the *f* function past *timeout* seconds.</span>

<span class="sd">    See example in :ref:`sample_inter`</span>

<span class="sd">    :return: manager of the later (Timer in thread,</span>
<span class="sd">        Greenlet in green_thread)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">intervals</span><span class="o">.</span><span class="n">later</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="proxy">
<span id="proxy-source"></span><h2>Proxy<a class="headerlink" href="#proxy" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Queue</span> <span class="k">import</span> <span class="n">Empty</span>

<span class="kn">from</span> <span class="nn">util</span> <span class="k">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">set_actor</span><span class="p">(</span><span class="n">module_name</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">actorm</span>
    <span class="n">actorm</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">module_name</span> <span class="o">+</span> <span class="s1">&#39;.actor&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span>
                        <span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Proxy</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Proxy is the class that supports to create a remote reference to an</span>
<span class="sd">    actor and invoke its methods.</span>

<span class="sd">    :param Actor actor: the actor the proxy will manage.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">actor</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__channel</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">channel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="o">=</span> <span class="n">actor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">get_lock</span><span class="p">()</span>
        <span class="c1"># print &quot;At proxy&quot;,self.__lock#, self.actor</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">actor</span><span class="o">.</span><span class="n">ask_ref</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">AskRefWrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__channel</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                                                <span class="n">actor</span><span class="o">.</span><span class="n">url</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">actor</span><span class="o">.</span><span class="n">tell_ref</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">TellRefWrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__channel</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                                                 <span class="n">actor</span><span class="o">.</span><span class="n">url</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">actor</span><span class="o">.</span><span class="n">tell</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">TellWrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__channel</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                                              <span class="n">actor</span><span class="o">.</span><span class="n">url</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">actor</span><span class="o">.</span><span class="n">ask</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">AskWrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__channel</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                                             <span class="n">actor</span><span class="o">.</span><span class="n">url</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Proxy(actor=</span><span class="si">%s</span><span class="s1">, tell=</span><span class="si">%s</span><span class="s1"> ref=</span><span class="si">%s</span><span class="s1">, ask=</span><span class="si">%s</span><span class="s1"> ref=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">tell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">tell_ref</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">ask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">ask_ref</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Future</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Future manages the remote method invocations that returns a result.</span>
<span class="sd">    Mostly for ask requests.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">actor_channel</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">actor_url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__channel</span> <span class="o">=</span> <span class="n">actorm</span><span class="o">.</span><span class="n">Channel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__actor_channel</span> <span class="o">=</span> <span class="n">actor_channel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__target</span> <span class="o">=</span> <span class="n">actor_url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">get_lock</span><span class="p">()</span>

    <span class="c1"># def __getattr__(self, name):</span>
    <span class="c1">#     raise Exception(&quot;&#39;Future&#39; object has no attribute %r. Remember to \</span>
    <span class="c1">#                     call get() after an ask query.&quot; % name)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Invokes the method sending a query through the channel and</span>
<span class="sd">        obtains the result of this method.</span>

<span class="sd">        It is necessary to invoke this method with a synchronous query</span>
<span class="sd">        in order to get the result. As in :ref:`sample2`::</span>

<span class="sd">            e1.say_something().get()</span>

<span class="sd">        Unless you use this method, you will get the future itself,</span>
<span class="sd">        which means the method has not been invoked yet, like in</span>
<span class="sd">        :ref:`sample3`::</span>

<span class="sd">            future = self.echo.say_something()</span>

<span class="sd">        In this case, you could set a callback with</span>
<span class="sd">        :meth:`add_callback`, so the result will be sent to the method</span>
<span class="sd">        you specify.</span>

<span class="sd">        :param int timeout: timeout to wait for the result. If not</span>
<span class="sd">            specified, it&#39;s set to 1 sec.</span>
<span class="sd">        :returns: the result of the invoked method. Could be any type.</span>
<span class="sd">        :raises: :class:`TimeoutError`, or an error receiving from the</span>
<span class="sd">            channel.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#  SENDING MESSAGE ASK</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">AskRequest</span><span class="p">(</span><span class="n">ASK</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__channel</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">__target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__actor_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="c1"># print &quot;At get, release&quot;,self.__lock, self.__method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__channel</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">result</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="n">AlreadyExistsError</span><span class="p">,</span> <span class="n">ae</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ae</span>
        <span class="k">except</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">TimeoutError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets a callback on the Future. This will generate a new</span>
<span class="sd">        :class:`~.FutureRequest` sent to the actor that will invoke</span>
<span class="sd">        the callback function with the result by parameter.</span>

<span class="sd">        In :ref:`sample3` you can see how to use it::</span>

<span class="sd">            future = self.echo.say_something()</span>
<span class="sd">            future.add_callback(&#39;pong&#39;)</span>

<span class="sd">        pong is a method of the same class that receives the result of</span>
<span class="sd">        the query in parameter *msg*::</span>

<span class="sd">            def pong(self,msg):</span>
<span class="sd">                print &#39;callback&#39;,msg</span>

<span class="sd">        :param str. callback: name of the function where to send the</span>
<span class="sd">            response.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">from_actor</span> <span class="o">=</span> <span class="n">get_current</span><span class="p">()</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">FutureRequest</span><span class="p">(</span><span class="n">FUTURE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__params</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
                            <span class="n">from_actor</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__target</span><span class="p">,</span>
                            <span class="n">from_actor</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__actor_channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FutureRef</span><span class="p">(</span><span class="n">Future</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">FutureRef</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">get_host</span><span class="p">()</span><span class="o">.</span><span class="n">_loads</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TellWrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper for Tell type queries to the proxy. Creates the request and</span>
<span class="sd">    sends it through the channel.</span>

<span class="sd">    :param Channel channel: communication way for the query.</span>
<span class="sd">    :param str. method: name of the method this query is gonna invoke.</span>
<span class="sd">    :param str. actor_url: URL address where the actor is set.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">actor_url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__channel</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__target</span> <span class="o">=</span> <span class="n">actor_url</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># _from = get_current()</span>
        <span class="c1">#  SENDING MESSAGE TELL</span>
        <span class="c1"># msg = (_from, self.__target, TELL, self.__method,args)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">TellRequest</span><span class="p">(</span><span class="n">TELL</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AskWrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper for Ask type queries to the proxy. Creates a :class:`Future`</span>
<span class="sd">    to manage the result reply.</span>

<span class="sd">    :param Channel channel: communication way for the query.</span>
<span class="sd">    :param str. method: name of the method this query is gonna invoke.</span>
<span class="sd">    :param str. actor_url: URL address where the actor is set.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">actor_url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_channel</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">actor_url</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Future</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_channel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AskRefWrapper</span><span class="p">(</span><span class="n">AskWrapper</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper for Ask queries that have a proxy in parameters or returns.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">new_args</span> <span class="o">=</span> <span class="n">get_host</span><span class="p">()</span><span class="o">.</span><span class="n">_dumps</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">FutureRef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_channel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span><span class="p">,</span> <span class="n">new_args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TellRefWrapper</span><span class="p">(</span><span class="n">TellWrapper</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Wrapper for Tell queries that have a proxy in parameters.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">new_args</span> <span class="o">=</span> <span class="n">get_host</span><span class="p">()</span><span class="o">.</span><span class="n">_dumps</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TellRefWrapper</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="thread-actor">
<span id="tactor-source"></span><h2>Thread Actor<a class="headerlink" href="#thread-actor" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Queue</span> <span class="k">import</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">Empty</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="k">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>

<span class="kn">from</span> <span class="nn">pyactor.util</span> <span class="k">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">Channel</span><span class="p">(</span><span class="n">Queue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Channel is the main communication mechanism between actors. It is</span>
<span class="sd">    actually a simple facade to the Queue.Queue python class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Queue</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It sends a message to the current channel.</span>

<span class="sd">        :param msg: The message sent to an actor. It is a tuple using</span>
<span class="sd">            the constants in util.py (:mod:`pyactor.util`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It receives a message from the channel, blocking the calling</span>
<span class="sd">        thread until the response is received, or the timeout is</span>
<span class="sd">        triggered.</span>

<span class="sd">        :param int timeout: timeout to wait for messages. If none</span>
<span class="sd">            provided it will block until a message arrives.</span>
<span class="sd">        :return: returns a message sent to the channel. It is a tuple</span>
<span class="sd">            using the constants in util.py (:mod:`pyactor.util`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ActorRef</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    ActorRef contains the main components of an actor. These are the</span>
<span class="sd">    URL where it is located, the communication :class:`~.Channel` and</span>
<span class="sd">    the class of the actor as also the synchronous and asynchronous</span>
<span class="sd">    methods the class implements. When no channel is specified a new</span>
<span class="sd">    one will be created wich is also the default procedure.</span>

<span class="sd">    .. note:: This is a superclass of :py:class:`Actor` and has no</span>
<span class="sd">        direct functionality.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tell</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ask</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">channel</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">Channel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="s1">&#39;_tell&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">klass</span><span class="o">.</span><span class="n">_tell</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tell</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_tell</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="s1">&#39;_ask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">klass</span><span class="o">.</span><span class="n">_ask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ask</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_ask</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="s1">&#39;_ref&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tell_ref</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_ref</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ask_ref</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_ref</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ask_ref</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ask</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell_ref</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ask_ref</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tell_ref</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">klass</span> <span class="o">=</span> <span class="n">klass</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Actor(url=</span><span class="si">%s</span><span class="s1">, class=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">klass</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Actor</span><span class="p">(</span><span class="n">ActorRef</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Actor is the instance of an object to which is possible to acces</span>
<span class="sd">    and invoke its methods remotely. Main element of the model. The</span>
<span class="sd">    host is the one to create them (spawning -&gt; see :meth:`~.spawn`).</span>

<span class="sd">    :param str. url: URL where the actor is running.</span>
<span class="sd">    :param class klass: class type for the actor.</span>
<span class="sd">    :param klass obj: instance of the *klass* class to attach to the</span>
<span class="sd">        actor.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Actor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;stop&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__processQueue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">receive</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :return: (*bool.*) identifies the current state of the actor.</span>
<span class="sd">            **True** if it is running.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span>

    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The message received from the queue specify a method of the</span>
<span class="sd">        class the actor represents. This invokes it. If the</span>
<span class="sd">        communication is an :class:`~.AskRequest`, sends the result back</span>
<span class="sd">        to the channel included in the message as an</span>
<span class="sd">        :class:`~.AskResponse`.</span>

<span class="sd">        If it is a :class:`~.Future`, generates a :class:`~.TellRequest`</span>
<span class="sd">        to send the result to the sender&#39;s method specified in the</span>
<span class="sd">        callback field of the tuple.</span>

<span class="sd">        :param msg: The message is a namedtuple of the defined in</span>
<span class="sd">            util.py (:class:`~.AskRequest`, :class:`~.TellRequest`,</span>
<span class="sd">            :class:`~.FutureRequest`).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">invoke</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">params</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">invoke</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">e</span>
                <span class="nb">print</span> <span class="n">result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_response</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ASK</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">AskResponse</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">FUTURE</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">TellRequest</span><span class="p">(</span><span class="n">TELL</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="p">[</span><span class="n">result</span><span class="p">],</span> <span class="n">msg</span><span class="o">.</span><span class="n">from_url</span><span class="p">)</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Creates the actor thread wich will process the channel queue</span>
<span class="sd">        while the actor :meth:`is_alive`, making it able to receive</span>
<span class="sd">        queries.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__processQueue</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="thread-intervals">
<span id="tintervals-source"></span><h2>Thread Intervals<a class="headerlink" href="#thread-intervals" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="k">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">Timer</span><span class="p">,</span> <span class="n">Event</span><span class="p">,</span> <span class="n">currentThread</span>
<span class="kn">import</span> <span class="nn">time</span> <span class="k">as</span> <span class="nn">timep</span>


<span class="k">def</span> <span class="nf">sleep</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Facade for the sleep function. Aboid using time.sleep.</span>

<span class="sd">    :param  int time: time to sleep, in seconds. (Float for second</span>
<span class="sd">        divisions)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">timep</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">later</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Sets a timer that will call the *f* function past *timeout* seconds.</span>

<span class="sd">    See example in :ref:`sample_inter`</span>

<span class="sd">    :return: :class:`Timer`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">t</span>


<span class="k">def</span> <span class="nf">interval_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creates an Event attached to the *host* that will execute the *f*</span>
<span class="sd">    function every *time* seconds.</span>

<span class="sd">    See example in :ref:`sample_inter`</span>

<span class="sd">    :param Proxy host: proxy of the host. Can be obtained from inside a</span>
<span class="sd">        class with ``self.host``.</span>
<span class="sd">    :param int time: seconds for the intervals.</span>
<span class="sd">    :param func f: function to be called every *time* seconds.</span>
<span class="sd">    :param list args: arguments for *f*.</span>
<span class="sd">    :return: :class:`Event` instance of the interval.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">thread</span> <span class="o">=</span> <span class="n">currentThread</span><span class="p">()</span>
        <span class="n">thread</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">stop_event</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">stop_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">host</span><span class="o">.</span><span class="n">detach_interval</span><span class="p">(</span><span class="n">thread_id</span><span class="p">)</span>
    <span class="n">t2_stop</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t2_stop</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">thread_id</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
    <span class="n">host</span><span class="o">.</span><span class="n">attach_interval</span><span class="p">(</span><span class="n">thread_id</span><span class="p">,</span> <span class="n">t2_stop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t2_stop</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="thread-parallel">
<span id="tparallels-source"></span><h2>Thread Parallel<a class="headerlink" href="#thread-parallel" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="k">import</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">Thread</span>

<span class="kn">from</span> <span class="nn">actor</span> <span class="k">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">ActorParallel</span><span class="p">(</span><span class="n">Actor</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Actor with parallel methods. Parallel methods are invoked in new</span>
<span class="sd">    threads, so their invocation do not block the actor allowing it to</span>
<span class="sd">    process many queries at a time.</span>
<span class="sd">    To aboid concurrence problems, this actors use Locks to guarantee</span>
<span class="sd">    its correct state.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ActorParallel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ask_parallel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ask</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ask_ref</span><span class="p">))</span> <span class="o">&amp;</span>
                                 <span class="nb">set</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_parallel</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tell_parallel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tell_ref</span><span class="p">))</span> <span class="o">&amp;</span>
                                  <span class="nb">set</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_parallel</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ask_parallel</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                    <span class="n">ParallelAskWraper</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">method</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell_parallel</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                    <span class="n">ParallelTellWraper</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">method</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Overwriting :meth:`Actor.receive`, adds the checks and</span>
<span class="sd">        functionalities requiered by parallel methods.</span>

<span class="sd">        :param msg: The message is a namedtuple of the defined in</span>
<span class="sd">            util.py (:class:`~.AskRequest`, :class:`~.TellRequest`,</span>
<span class="sd">            :class:`~.FutureRequest`).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">invoke</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">params</span>

                <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ask_parallel</span><span class="p">:</span>
                    <span class="n">rpc_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
                    <span class="c1"># add rpc message to pendent AskResponse s</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">rpc_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span>
                    <span class="c1"># insert an rpc id to args</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                    <span class="n">params</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rpc_id</span><span class="p">)</span>
                    <span class="n">invoke</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span>
                    <span class="k">return</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">invoke</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">e</span>
                <span class="nb">print</span> <span class="n">result</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">send_response</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">receive_from_ask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">rpc_id</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">rpc_id</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">rpc_id</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_response</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :return: :class:`Lock` of the actor.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span>


<span class="k">class</span> <span class="nc">ParallelAskWraper</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;Wrapper for ask methods that have to be called in a parallel form.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">actor</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__actor</span> <span class="o">=</span> <span class="n">actor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">lock</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">rpc_id</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">rpc_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rpc_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">,</span> <span class="n">rpc_id</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">invoke</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                <span class="n">get_host</span><span class="p">()</span><span class="o">.</span><span class="n">new_parallel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__actor</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">rpc_id</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__actor</span><span class="o">.</span><span class="n">receive_from_ask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">rpc_id</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ParallelTellWraper</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper for tell methods that have to be called in a parallel form.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">actor</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__actor</span> <span class="o">=</span> <span class="n">actor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">lock</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">param</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">invoke</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">get_host</span><span class="p">()</span><span class="o">.</span><span class="n">new_parallel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__actor</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="green-thread-actor">
<span id="gactor-source"></span><h2>Green Thread Actor<a class="headerlink" href="#green-thread-actor" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>

<span class="kn">import</span> <span class="nn">gevent</span>
<span class="kn">from</span> <span class="nn">gevent.queue</span> <span class="k">import</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">Empty</span>

<span class="kn">from</span> <span class="nn">pyactor.util</span> <span class="k">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">Channel</span><span class="p">(</span><span class="n">Queue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Channel is the main communication mechanism between actors. It is</span>
<span class="sd">    actually a simple facade to the gevent.Queue class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Queue</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It sends a message to the current channel.</span>

<span class="sd">        :param msg: The message sent to an actor. It is a tuple using</span>
<span class="sd">            the constants in util.py (:mod:`pyactor.util`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It receives a message from the channel, blocking the calling</span>
<span class="sd">        thread until the response is received, or the timeout is</span>
<span class="sd">        triggered.</span>

<span class="sd">        :param int timeout: timeout to wait for messages. If none</span>
<span class="sd">            provided it will block until a message arrives.</span>
<span class="sd">        :return: returns a message sent to the channel. It is a tuple</span>
<span class="sd">            using the constants in util.py (:mod:`pyactor.util`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ActorRef</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    ActorRef contains the main components of an actor. These are the</span>
<span class="sd">    URL where it is located, the communication :class:`~.Channel` and</span>
<span class="sd">    the class of the actor as also the synchronous and asynchronous</span>
<span class="sd">    methods the class implements. When no channel is specified a new</span>
<span class="sd">    one will be created wich is also the default procedure.</span>

<span class="sd">    .. note:: This is a superclass of :py:class:`Actor` and has no</span>
<span class="sd">        direct functionality.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tell</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ask</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">channel</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">Channel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="s1">&#39;_tell&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">klass</span><span class="o">.</span><span class="n">_tell</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tell</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_tell</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="s1">&#39;_ask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">klass</span><span class="o">.</span><span class="n">_ask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ask</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_ask</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="s1">&#39;_ref&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tell_ref</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_ref</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ask_ref</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_ref</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ask_ref</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ask</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell_ref</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ask_ref</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tell_ref</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">klass</span> <span class="o">=</span> <span class="n">klass</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Actor(url=</span><span class="si">%s</span><span class="s1">, class=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">klass</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Actor</span><span class="p">(</span><span class="n">ActorRef</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Actor is the instance of an object to which is possible to acces</span>
<span class="sd">    and invoke its methods remotely. Main element of the model. The</span>
<span class="sd">    host is the one to create them (spawning -&gt; see :meth:`~.spawn`).</span>

<span class="sd">    :param str. url: URL where the actor is running.</span>
<span class="sd">    :param class klass: class type for the actor.</span>
<span class="sd">    :param klass obj: instance of the *klass* class to attach to the</span>
<span class="sd">        actor.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Actor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;stop&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__processQueue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">receive</span><span class="p">()</span>  <span class="c1"># Timeout = None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :return: (*bool.*) identifies the current state of the actor.</span>
<span class="sd">            **True** if it is running.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span>

    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The message received from the queue specify a method of the</span>
<span class="sd">        class the actor represents. This invokes it. If the</span>
<span class="sd">        communication is an :class:`~.AskRequest`, sends the result back</span>
<span class="sd">        to the channel included in the message as an</span>
<span class="sd">        :class:`~.AskResponse`.</span>

<span class="sd">        If it is a :class:`~.Future`, generates a :class:`~.TellRequest`</span>
<span class="sd">        to send the result to the sender&#39;s method specified in the</span>
<span class="sd">        callback field of the tuple.</span>

<span class="sd">        :param msg: The message is a namedtuple of the defined in</span>
<span class="sd">            util.py (:class:`~.AskRequest`, :class:`~.TellRequest`,</span>
<span class="sd">            :class:`~.FutureRequest`).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">invoke</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">params</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">invoke</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">e</span>
                <span class="nb">print</span> <span class="n">result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_response</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ASK</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">AskResponse</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">FUTURE</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">TellRequest</span><span class="p">(</span><span class="n">TELL</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="p">[</span><span class="n">result</span><span class="p">],</span> <span class="n">msg</span><span class="o">.</span><span class="n">from_url</span><span class="p">)</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Creates the actor thread wich will process the channel queue</span>
<span class="sd">        while the actor :meth:`is_alive`, making it able to receive</span>
<span class="sd">        queries.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span> <span class="o">=</span> <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__processQueue</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="grenn-thread-intervals">
<span id="gintervals-source"></span><h2>Grenn Thread Intervals<a class="headerlink" href="#grenn-thread-intervals" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">gevent.event</span> <span class="k">import</span> <span class="n">Event</span>
<span class="kn">from</span> <span class="nn">gevent</span> <span class="k">import</span> <span class="n">getcurrent</span>
<span class="kn">import</span> <span class="nn">gevent</span>


<span class="k">def</span> <span class="nf">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Facade for the sleep function. Do not use time.sleep if you are</span>
<span class="sd">    running green threads.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">gevent</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">later</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Sets a timer that will call the *f* function past *timeout* seconds.</span>

<span class="sd">    See example in :ref:`sample_inter`</span>

<span class="sd">    :return: :class:`Greenlet` new &#39;thread&#39; which will perform the call</span>
<span class="sd">        when specified.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">sleep</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">wrap</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">interval_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creates an Event attached to the *host* for management that will</span>
<span class="sd">    execute the *f* function every *time* seconds.</span>

<span class="sd">    See example in :ref:`sample_inter`</span>

<span class="sd">    :param Proxy host: proxy of the host. Can be obtained from inside a</span>
<span class="sd">        class with ``self.host``.</span>
<span class="sd">    :param int time: seconds for the intervals.</span>
<span class="sd">    :param func f: function to be called every *time* seconds.</span>
<span class="sd">    :param list args: arguments for *f*.</span>
<span class="sd">    :return: :class:`Event` instance of the interval.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">thread</span> <span class="o">=</span> <span class="n">getcurrent</span><span class="p">()</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">stop_event</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">stop_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">stop_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">host</span><span class="o">.</span><span class="n">detach_interval</span><span class="p">(</span><span class="n">thread</span><span class="p">)</span>
    <span class="n">t2_stop</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t2_stop</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">wrap</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">thread_id</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">host</span><span class="o">.</span><span class="n">attach_interval</span><span class="p">(</span><span class="n">thread_id</span><span class="p">,</span> <span class="n">t2_stop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t2_stop</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="green-thread-parallel">
<span id="gparallels-source"></span><h2>Green Thread Parallel<a class="headerlink" href="#green-thread-parallel" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">uuid</span>

<span class="kn">from</span> <span class="nn">actor</span> <span class="k">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">ActorParallel</span><span class="p">(</span><span class="n">Actor</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Actor with parallel methods. Parallel methods are invoked in new</span>
<span class="sd">    threads, so their invocation do not block the actor allowing it to</span>
<span class="sd">    process many queries at a time.</span>
<span class="sd">    Green threads do not have concurrernce problems so no need to use</span>
<span class="sd">    Locks in this implementation.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ActorParallel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="c1"># self.__lock = Lock()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ask_parallel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ask</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ask_ref</span><span class="p">))</span> <span class="o">&amp;</span>
                                 <span class="nb">set</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_parallel</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tell_parallel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tell_ref</span><span class="p">))</span> <span class="o">&amp;</span>
                                  <span class="nb">set</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">_parallel</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ask_parallel</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                    <span class="n">ParallelAskWraper</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">method</span><span class="p">),</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell_parallel</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                    <span class="n">ParallelTellWraper</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">method</span><span class="p">),</span> <span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Overwriting :meth:`Actor.receive`, adds the checks and</span>
<span class="sd">        functionalities requiered by parallel methods.</span>

<span class="sd">        :param msg: The message is a namedtuple of the defined in</span>
<span class="sd">            util.py (:class:`~.AskRequest`, :class:`~.TellRequest`,</span>
<span class="sd">            :class:`~.FutureRequest`).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">invoke</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">params</span>

                <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ask_parallel</span><span class="p">:</span>
                    <span class="n">rpc_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
                    <span class="c1"># add rpc message to pendent AskResponse s</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">rpc_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span>
                    <span class="c1"># insert an rpc id to args</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                    <span class="n">params</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rpc_id</span><span class="p">)</span>
                    <span class="n">invoke</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span>
                    <span class="k">return</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># self.__lock.acquire()</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">invoke</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span>
                    <span class="c1"># self.__lock.release()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">e</span>
                <span class="nb">print</span> <span class="n">result</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">send_response</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">receive_from_ask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">rpc_id</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">rpc_id</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">rpc_id</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_response</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

<span class="c1"># For compatibility. Green threads do no use Locks.</span>
    <span class="k">def</span> <span class="nf">get_lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">ParallelAskWraper</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;Wrapper for ask methods that have to be called in a parallel form.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">actor</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__actor</span> <span class="o">=</span> <span class="n">actor</span>
        <span class="c1"># self.__lock = lock</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">rpc_id</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">rpc_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rpc_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">,</span> <span class="n">rpc_id</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invoke</span><span class="p">,</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
                <span class="n">get_host</span><span class="p">()</span><span class="o">.</span><span class="n">new_parallel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__actor</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">rpc_id</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">[]):</span>
        <span class="c1"># self.__lock.acquire()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">e</span>
        <span class="c1"># self.__lock.release()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__actor</span><span class="o">.</span><span class="n">receive_from_ask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">rpc_id</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ParallelTellWraper</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper for tell methods that have to be called in a parallel form.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">actor</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__actor</span> <span class="o">=</span> <span class="n">actor</span>
        <span class="c1"># self.__lock = lock</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">param</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invoke</span><span class="p">,</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
        <span class="n">get_host</span><span class="p">()</span><span class="o">.</span><span class="n">new_parallel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__actor</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">[]):</span>
        <span class="c1"># self.__lock.acquire()</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># self.__lock.release()</span>
</pre></div>
</td></tr></table></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Source</a><ul>
<li><a class="reference internal" href="#context">Context</a></li>
<li><a class="reference internal" href="#proxy">Proxy</a></li>
<li><a class="reference internal" href="#thread-actor">Thread Actor</a></li>
<li><a class="reference internal" href="#thread-intervals">Thread Intervals</a></li>
<li><a class="reference internal" href="#thread-parallel">Thread Parallel</a></li>
<li><a class="reference internal" href="#green-thread-actor">Green Thread Actor</a></li>
<li><a class="reference internal" href="#grenn-thread-intervals">Grenn Thread Intervals</a></li>
<li><a class="reference internal" href="#green-thread-parallel">Green Thread Parallel</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/source.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyActor 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, URV.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.
    </div>
  </body>
</html>